{"ast":null,"code":"var _jsxFileName = \"/Users/mattspacegrey/Documents/GitHub/SMT_DATABASE_01/src/contexts/SocketContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect, useRef } from 'react';\nimport { useAuth } from './AuthContext.tsx';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SSEContext = /*#__PURE__*/createContext(undefined);\nexport const SocketProvider = ({\n  children\n}) => {\n  _s();\n  const [connected, setConnected] = useState(false);\n  const [eventSource, setEventSource] = useState(null);\n  const {\n    user\n  } = useAuth();\n\n  // Use refs to store callbacks to avoid recreating SSE connection\n  const workOrderCallbacksRef = useRef([]);\n  const generalCallbacksRef = useRef([]);\n  useEffect(() => {\n    const token = localStorage.getItem('auth_token');\n    if (!token) {\n      console.log('❌ No auth token available for SSE');\n      return;\n    }\n    const isDev = process.env.NODE_ENV === 'development';\n\n    // Always use production URL for SSE since we're running local dev against production\n    const baseUrl = isDev ? 'https://smtdatabase01-production.up.railway.app' : window.location.origin;\n\n    // Include token in URL since EventSource doesn't support custom headers\n    const eventSourceUrl = `${baseUrl}/api/events?token=${encodeURIComponent(token)}`;\n    console.log('Connecting to SSE server:', eventSourceUrl);\n\n    // Create EventSource connection\n    const newEventSource = new EventSource(eventSourceUrl);\n    newEventSource.onopen = () => {\n      console.log('✅ Connected to SSE server');\n      setConnected(true);\n    };\n    newEventSource.onmessage = event => {\n      try {\n        const data = JSON.parse(event.data);\n        console.log('📡 Received SSE update:', data);\n\n        // Route the update to appropriate callbacks\n        if (data.type === 'work_order_update') {\n          workOrderCallbacksRef.current.forEach(callback => {\n            try {\n              callback(data);\n            } catch (error) {\n              console.error('Error in work order callback:', error);\n            }\n          });\n        } else {\n          // General update - send to all general callbacks\n          generalCallbacksRef.current.forEach(callback => {\n            try {\n              callback(data);\n            } catch (error) {\n              console.error('Error in general callback:', error);\n            }\n          });\n        }\n      } catch (error) {\n        console.error('Error parsing SSE message:', error);\n      }\n    };\n    newEventSource.onerror = error => {\n      console.error('❌ SSE connection error:', error);\n      setConnected(false);\n    };\n    setEventSource(newEventSource);\n\n    // Cleanup on unmount\n    return () => {\n      console.log('🔌 Closing SSE connection');\n      newEventSource.close();\n      setConnected(false);\n    };\n  }, [user]); // Depend on user to reconnect when auth changes\n\n  const onWorkOrderUpdate = callback => {\n    workOrderCallbacksRef.current.push(callback);\n\n    // Return cleanup function\n    return () => {\n      workOrderCallbacksRef.current = workOrderCallbacksRef.current.filter(cb => cb !== callback);\n    };\n  };\n  const onGeneralUpdate = callback => {\n    generalCallbacksRef.current.push(callback);\n\n    // Return cleanup function\n    return () => {\n      generalCallbacksRef.current = generalCallbacksRef.current.filter(cb => cb !== callback);\n    };\n  };\n  const contextValue = {\n    connected,\n    onWorkOrderUpdate,\n    onGeneralUpdate\n  };\n  return /*#__PURE__*/_jsxDEV(SSEContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 145,\n    columnNumber: 5\n  }, this);\n};\n_s(SocketProvider, \"VwxqZp4qQ6vgvbNzjcdYYsLFwic=\", false, function () {\n  return [useAuth];\n});\n_c = SocketProvider;\nexport function useSocket() {\n  _s2();\n  const context = useContext(SSEContext);\n  if (context === undefined) {\n    throw new Error('useSocket must be used within a SocketProvider');\n  }\n  return context;\n}\n_s2(useSocket, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"SocketProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useRef","useAuth","jsxDEV","_jsxDEV","SSEContext","undefined","SocketProvider","children","_s","connected","setConnected","eventSource","setEventSource","user","workOrderCallbacksRef","generalCallbacksRef","token","localStorage","getItem","console","log","isDev","process","env","NODE_ENV","baseUrl","window","location","origin","eventSourceUrl","encodeURIComponent","newEventSource","EventSource","onopen","onmessage","event","data","JSON","parse","type","current","forEach","callback","error","onerror","close","onWorkOrderUpdate","push","filter","cb","onGeneralUpdate","contextValue","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useSocket","_s2","context","Error","$RefreshReg$"],"sources":["/Users/mattspacegrey/Documents/GitHub/SMT_DATABASE_01/src/contexts/SocketContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, useRef, ReactNode } from 'react';\nimport { useAuth } from './AuthContext.tsx';\n\ninterface WorkOrderUpdate {\n  type: 'status_update';\n  work_order: {\n    id: string;\n    work_order_number: string;\n    qr_code?: string;\n    customer_name: string;\n    assembly_number: string;\n    line_name?: string;\n    line_number?: number;\n    status: string;\n    quantity?: number;\n    trolley_number?: number;\n  };\n  status_change: {\n    old_status: string;\n    new_status: string;\n    updated_by: string;\n    timestamp: string;\n  };\n  timestamp: string;\n}\n\ninterface GeneralUpdate {\n  type: string;\n  data: any;\n  timestamp: string;\n}\n\ninterface SSEContextType {\n  connected: boolean;\n  onWorkOrderUpdate: (callback: (update: WorkOrderUpdate) => void) => () => void;\n  onGeneralUpdate: (callback: (update: GeneralUpdate) => void) => () => void;\n}\n\nconst SSEContext = createContext<SSEContextType | undefined>(undefined);\n\nexport const SocketProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [connected, setConnected] = useState(false);\n  const [eventSource, setEventSource] = useState<EventSource | null>(null);\n  const { user } = useAuth();\n  \n  // Use refs to store callbacks to avoid recreating SSE connection\n  const workOrderCallbacksRef = useRef<((update: WorkOrderUpdate) => void)[]>([]);\n  const generalCallbacksRef = useRef<((data: any) => void)[]>([]);\n\n  useEffect(() => {\n    const token = localStorage.getItem('auth_token');\n    if (!token) {\n      console.log('❌ No auth token available for SSE');\n      return;\n    }\n\n    const isDev = process.env.NODE_ENV === 'development';\n    \n    // Always use production URL for SSE since we're running local dev against production\n    const baseUrl = isDev \n      ? 'https://smtdatabase01-production.up.railway.app'\n      : window.location.origin;\n\n    // Include token in URL since EventSource doesn't support custom headers\n    const eventSourceUrl = `${baseUrl}/api/events?token=${encodeURIComponent(token)}`;\n    console.log('Connecting to SSE server:', eventSourceUrl);\n\n    // Create EventSource connection\n    const newEventSource = new EventSource(eventSourceUrl);\n    \n    newEventSource.onopen = () => {\n      console.log('✅ Connected to SSE server');\n      setConnected(true);\n    };\n\n    newEventSource.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        console.log('📡 Received SSE update:', data);\n\n        // Route the update to appropriate callbacks\n        if (data.type === 'work_order_update') {\n          workOrderCallbacksRef.current.forEach(callback => {\n            try {\n              callback(data);\n            } catch (error) {\n              console.error('Error in work order callback:', error);\n            }\n          });\n        } else {\n          // General update - send to all general callbacks\n          generalCallbacksRef.current.forEach(callback => {\n            try {\n              callback(data);\n            } catch (error) {\n              console.error('Error in general callback:', error);\n            }\n          });\n        }\n      } catch (error) {\n        console.error('Error parsing SSE message:', error);\n      }\n    };\n\n    newEventSource.onerror = (error) => {\n      console.error('❌ SSE connection error:', error);\n      setConnected(false);\n    };\n\n    setEventSource(newEventSource);\n\n    // Cleanup on unmount\n    return () => {\n      console.log('🔌 Closing SSE connection');\n      newEventSource.close();\n      setConnected(false);\n    };\n  }, [user]); // Depend on user to reconnect when auth changes\n\n  const onWorkOrderUpdate = (callback: (update: WorkOrderUpdate) => void) => {\n    workOrderCallbacksRef.current.push(callback);\n    \n    // Return cleanup function\n    return () => {\n      workOrderCallbacksRef.current = workOrderCallbacksRef.current.filter(cb => cb !== callback);\n    };\n  };\n\n  const onGeneralUpdate = (callback: (data: any) => void) => {\n    generalCallbacksRef.current.push(callback);\n    \n    // Return cleanup function\n    return () => {\n      generalCallbacksRef.current = generalCallbacksRef.current.filter(cb => cb !== callback);\n    };\n  };\n\n  const contextValue: SSEContextType = {\n    connected,\n    onWorkOrderUpdate,\n    onGeneralUpdate\n  };\n\n  return (\n    <SSEContext.Provider value={contextValue}>\n      {children}\n    </SSEContext.Provider>\n  );\n}\n\nexport function useSocket() {\n  const context = useContext(SSEContext);\n  if (context === undefined) {\n    throw new Error('useSocket must be used within a SocketProvider');\n  }\n  return context;\n} "],"mappings":";;;AAAA,OAAOA,KAAK,IAAIC,aAAa,EAAEC,UAAU,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,MAAM,QAAmB,OAAO;AAChG,SAASC,OAAO,QAAQ,mBAAmB;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAqC5C,MAAMC,UAAU,gBAAGR,aAAa,CAA6BS,SAAS,CAAC;AAEvE,OAAO,MAAMC,cAAiD,GAAGA,CAAC;EAAEC;AAAS,CAAC,KAAK;EAAAC,EAAA;EACjF,MAAM,CAACC,SAAS,EAAEC,YAAY,CAAC,GAAGZ,QAAQ,CAAC,KAAK,CAAC;EACjD,MAAM,CAACa,WAAW,EAAEC,cAAc,CAAC,GAAGd,QAAQ,CAAqB,IAAI,CAAC;EACxE,MAAM;IAAEe;EAAK,CAAC,GAAGZ,OAAO,CAAC,CAAC;;EAE1B;EACA,MAAMa,qBAAqB,GAAGd,MAAM,CAAwC,EAAE,CAAC;EAC/E,MAAMe,mBAAmB,GAAGf,MAAM,CAA0B,EAAE,CAAC;EAE/DD,SAAS,CAAC,MAAM;IACd,MAAMiB,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,YAAY,CAAC;IAChD,IAAI,CAACF,KAAK,EAAE;MACVG,OAAO,CAACC,GAAG,CAAC,mCAAmC,CAAC;MAChD;IACF;IAEA,MAAMC,KAAK,GAAGC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,aAAa;;IAEpD;IACA,MAAMC,OAAO,GAAGJ,KAAK,GACjB,iDAAiD,GACjDK,MAAM,CAACC,QAAQ,CAACC,MAAM;;IAE1B;IACA,MAAMC,cAAc,GAAG,GAAGJ,OAAO,qBAAqBK,kBAAkB,CAACd,KAAK,CAAC,EAAE;IACjFG,OAAO,CAACC,GAAG,CAAC,2BAA2B,EAAES,cAAc,CAAC;;IAExD;IACA,MAAME,cAAc,GAAG,IAAIC,WAAW,CAACH,cAAc,CAAC;IAEtDE,cAAc,CAACE,MAAM,GAAG,MAAM;MAC5Bd,OAAO,CAACC,GAAG,CAAC,2BAA2B,CAAC;MACxCV,YAAY,CAAC,IAAI,CAAC;IACpB,CAAC;IAEDqB,cAAc,CAACG,SAAS,GAAIC,KAAK,IAAK;MACpC,IAAI;QACF,MAAMC,IAAI,GAAGC,IAAI,CAACC,KAAK,CAACH,KAAK,CAACC,IAAI,CAAC;QACnCjB,OAAO,CAACC,GAAG,CAAC,yBAAyB,EAAEgB,IAAI,CAAC;;QAE5C;QACA,IAAIA,IAAI,CAACG,IAAI,KAAK,mBAAmB,EAAE;UACrCzB,qBAAqB,CAAC0B,OAAO,CAACC,OAAO,CAACC,QAAQ,IAAI;YAChD,IAAI;cACFA,QAAQ,CAACN,IAAI,CAAC;YAChB,CAAC,CAAC,OAAOO,KAAK,EAAE;cACdxB,OAAO,CAACwB,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAAC;YACvD;UACF,CAAC,CAAC;QACJ,CAAC,MAAM;UACL;UACA5B,mBAAmB,CAACyB,OAAO,CAACC,OAAO,CAACC,QAAQ,IAAI;YAC9C,IAAI;cACFA,QAAQ,CAACN,IAAI,CAAC;YAChB,CAAC,CAAC,OAAOO,KAAK,EAAE;cACdxB,OAAO,CAACwB,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;YACpD;UACF,CAAC,CAAC;QACJ;MACF,CAAC,CAAC,OAAOA,KAAK,EAAE;QACdxB,OAAO,CAACwB,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;MACpD;IACF,CAAC;IAEDZ,cAAc,CAACa,OAAO,GAAID,KAAK,IAAK;MAClCxB,OAAO,CAACwB,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;MAC/CjC,YAAY,CAAC,KAAK,CAAC;IACrB,CAAC;IAEDE,cAAc,CAACmB,cAAc,CAAC;;IAE9B;IACA,OAAO,MAAM;MACXZ,OAAO,CAACC,GAAG,CAAC,2BAA2B,CAAC;MACxCW,cAAc,CAACc,KAAK,CAAC,CAAC;MACtBnC,YAAY,CAAC,KAAK,CAAC;IACrB,CAAC;EACH,CAAC,EAAE,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC;;EAEZ,MAAMiC,iBAAiB,GAAIJ,QAA2C,IAAK;IACzE5B,qBAAqB,CAAC0B,OAAO,CAACO,IAAI,CAACL,QAAQ,CAAC;;IAE5C;IACA,OAAO,MAAM;MACX5B,qBAAqB,CAAC0B,OAAO,GAAG1B,qBAAqB,CAAC0B,OAAO,CAACQ,MAAM,CAACC,EAAE,IAAIA,EAAE,KAAKP,QAAQ,CAAC;IAC7F,CAAC;EACH,CAAC;EAED,MAAMQ,eAAe,GAAIR,QAA6B,IAAK;IACzD3B,mBAAmB,CAACyB,OAAO,CAACO,IAAI,CAACL,QAAQ,CAAC;;IAE1C;IACA,OAAO,MAAM;MACX3B,mBAAmB,CAACyB,OAAO,GAAGzB,mBAAmB,CAACyB,OAAO,CAACQ,MAAM,CAACC,EAAE,IAAIA,EAAE,KAAKP,QAAQ,CAAC;IACzF,CAAC;EACH,CAAC;EAED,MAAMS,YAA4B,GAAG;IACnC1C,SAAS;IACTqC,iBAAiB;IACjBI;EACF,CAAC;EAED,oBACE/C,OAAA,CAACC,UAAU,CAACgD,QAAQ;IAACC,KAAK,EAAEF,YAAa;IAAA5C,QAAA,EACtCA;EAAQ;IAAA+C,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACU,CAAC;AAE1B,CAAC;AAAAjD,EAAA,CA5GYF,cAAiD;EAAA,QAG3CL,OAAO;AAAA;AAAAyD,EAAA,GAHbpD,cAAiD;AA8G9D,OAAO,SAASqD,SAASA,CAAA,EAAG;EAAAC,GAAA;EAC1B,MAAMC,OAAO,GAAGhE,UAAU,CAACO,UAAU,CAAC;EACtC,IAAIyD,OAAO,KAAKxD,SAAS,EAAE;IACzB,MAAM,IAAIyD,KAAK,CAAC,gDAAgD,CAAC;EACnE;EACA,OAAOD,OAAO;AAChB;AAACD,GAAA,CANeD,SAAS;AAAA,IAAAD,EAAA;AAAAK,YAAA,CAAAL,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}