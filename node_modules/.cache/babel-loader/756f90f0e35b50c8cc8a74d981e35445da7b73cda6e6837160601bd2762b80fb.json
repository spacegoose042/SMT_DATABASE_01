{"ast":null,"code":"var _jsxFileName = \"/Users/mattspacegrey/Documents/GitHub/SMT_DATABASE_01/src/contexts/SocketContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect, useRef } from 'react';\nimport { useAuth } from './AuthContext.tsx';\nimport { io } from 'socket.io-client';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SSEContext = /*#__PURE__*/createContext(undefined);\nexport const SocketProvider = ({\n  children\n}) => {\n  _s();\n  const [connected, setConnected] = useState(false); // SSE connection\n  const [socketConnected, setSocketConnected] = useState(false); // Socket.IO connection\n  const [eventSource, setEventSource] = useState(null);\n  const [socket, setSocket] = useState(null);\n  const {\n    user\n  } = useAuth();\n\n  // Use refs to store callbacks to avoid recreating connections\n  const workOrderCallbacksRef = useRef([]);\n  const generalCallbacksRef = useRef([]);\n\n  // SSE Connection Setup\n  useEffect(() => {\n    const token = localStorage.getItem('auth_token');\n    if (!token) {\n      console.log('‚ùå No auth token available for SSE');\n      return;\n    }\n    const isDev = process.env.NODE_ENV === 'development';\n\n    // Always use production URL for SSE since we're running local dev against production\n    const baseUrl = isDev ? 'https://smtdatabase01-production.up.railway.app' : window.location.origin;\n\n    // Include token in URL since EventSource doesn't support custom headers\n    const eventSourceUrl = `${baseUrl}/api/events?token=${encodeURIComponent(token)}`;\n    console.log('Connecting to SSE server:', eventSourceUrl);\n\n    // Create EventSource connection\n    const newEventSource = new EventSource(eventSourceUrl);\n    newEventSource.onopen = () => {\n      console.log('‚úÖ Connected to SSE server');\n      setConnected(true);\n    };\n    newEventSource.onmessage = event => {\n      try {\n        const data = JSON.parse(event.data);\n        console.log('üì° Received SSE update:', data);\n\n        // Route the update to appropriate callbacks\n        if (data.type === 'work_order_update') {\n          workOrderCallbacksRef.current.forEach(callback => {\n            try {\n              callback(data);\n            } catch (error) {\n              console.error('Error in work order callback:', error);\n            }\n          });\n        } else {\n          // General update - send to all general callbacks\n          generalCallbacksRef.current.forEach(callback => {\n            try {\n              callback(data);\n            } catch (error) {\n              console.error('Error in general callback:', error);\n            }\n          });\n        }\n      } catch (error) {\n        console.error('Error parsing SSE message:', error);\n      }\n    };\n    newEventSource.onerror = error => {\n      console.error('‚ùå SSE connection error:', error);\n      setConnected(false);\n    };\n    setEventSource(newEventSource);\n\n    // Cleanup on unmount\n    return () => {\n      console.log('üîå Closing SSE connection');\n      newEventSource.close();\n      setConnected(false);\n    };\n  }, [user]); // Depend on user to reconnect when auth changes\n\n  // Socket.IO Connection Setup\n  useEffect(() => {\n    const token = localStorage.getItem('auth_token');\n    if (!token) {\n      console.log('‚ùå No auth token available for Socket.IO');\n      return;\n    }\n    const isDev = process.env.NODE_ENV === 'development';\n    const baseUrl = isDev ? 'https://smtdatabase01-production.up.railway.app' : window.location.origin;\n    console.log('üîå Connecting to Socket.IO server:', baseUrl);\n\n    // Create Socket.IO connection with auth\n    const newSocket = io(baseUrl, {\n      auth: {\n        token: token\n      }\n    });\n    newSocket.on('connect', () => {\n      console.log('‚úÖ Connected to Socket.IO server');\n      setSocketConnected(true);\n    });\n    newSocket.on('disconnect', () => {\n      console.log('‚ùå Disconnected from Socket.IO server');\n      setSocketConnected(false);\n    });\n    newSocket.on('connected', data => {\n      console.log('üîó Socket.IO handshake:', data);\n    });\n    newSocket.on('work_order_update', data => {\n      console.log('üöÄ Received Socket.IO work order update:', data);\n\n      // Route to work order callbacks (same as SSE)\n      workOrderCallbacksRef.current.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error('Error in Socket.IO work order callback:', error);\n        }\n      });\n    });\n    newSocket.on('error', error => {\n      console.error('‚ùå Socket.IO error:', error);\n    });\n    setSocket(newSocket);\n\n    // Cleanup on unmount\n    return () => {\n      console.log('üîå Closing Socket.IO connection');\n      newSocket.disconnect();\n      setSocketConnected(false);\n    };\n  }, [user]);\n  const onWorkOrderUpdate = callback => {\n    workOrderCallbacksRef.current.push(callback);\n\n    // Return cleanup function\n    return () => {\n      workOrderCallbacksRef.current = workOrderCallbacksRef.current.filter(cb => cb !== callback);\n    };\n  };\n  const onGeneralUpdate = callback => {\n    generalCallbacksRef.current.push(callback);\n\n    // Return cleanup function\n    return () => {\n      generalCallbacksRef.current = generalCallbacksRef.current.filter(cb => cb !== callback);\n    };\n  };\n  const joinRooms = rooms => {\n    if (socket && socketConnected) {\n      rooms.forEach(room => {\n        console.log(`üè† Joining Socket.IO room: ${room}`);\n        socket.emit('join_room', {\n          room\n        });\n      });\n    } else {\n      console.log('‚ö†Ô∏è Socket.IO not connected, cannot join rooms');\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(SSEContext.Provider, {\n    value: {\n      connected,\n      socketConnected,\n      onWorkOrderUpdate,\n      onGeneralUpdate,\n      joinRooms\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 219,\n    columnNumber: 5\n  }, this);\n};\n_s(SocketProvider, \"rqeqvRV5uf23CuRfkZwG2qqrkkk=\", false, function () {\n  return [useAuth];\n});\n_c = SocketProvider;\nexport const useSocket = () => {\n  _s2();\n  const context = useContext(SSEContext);\n  if (context === undefined) {\n    throw new Error('useSocket must be used within a SocketProvider');\n  }\n  return context;\n};\n_s2(useSocket, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"SocketProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useRef","useAuth","io","jsxDEV","_jsxDEV","SSEContext","undefined","SocketProvider","children","_s","connected","setConnected","socketConnected","setSocketConnected","eventSource","setEventSource","socket","setSocket","user","workOrderCallbacksRef","generalCallbacksRef","token","localStorage","getItem","console","log","isDev","process","env","NODE_ENV","baseUrl","window","location","origin","eventSourceUrl","encodeURIComponent","newEventSource","EventSource","onopen","onmessage","event","data","JSON","parse","type","current","forEach","callback","error","onerror","close","newSocket","auth","on","disconnect","onWorkOrderUpdate","push","filter","cb","onGeneralUpdate","joinRooms","rooms","room","emit","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useSocket","_s2","context","Error","$RefreshReg$"],"sources":["/Users/mattspacegrey/Documents/GitHub/SMT_DATABASE_01/src/contexts/SocketContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, useRef, ReactNode } from 'react';\nimport { useAuth } from './AuthContext.tsx';\nimport { io, Socket } from 'socket.io-client';\n\ninterface WorkOrderUpdate {\n  type: 'work_order_update';\n  work_order: {\n    id: string;\n    work_order_number: string;\n    qr_code?: string;\n    customer_name: string;\n    assembly_number: string;\n    line_name?: string;\n    line_number?: number;\n    status: string;\n    quantity?: number;\n    trolley_number?: number;\n  };\n  status_change: {\n    old_status: string;\n    new_status: string;\n    updated_by: string;\n    timestamp: string;\n  };\n  timestamp: string;\n}\n\ninterface GeneralUpdate {\n  type: string;\n  data: any;\n  timestamp: string;\n}\n\ninterface SSEContextType {\n  connected: boolean;\n  socketConnected: boolean;\n  onWorkOrderUpdate: (callback: (update: WorkOrderUpdate) => void) => () => void;\n  onGeneralUpdate: (callback: (data: any) => void) => () => void;\n  joinRooms: (rooms: string[]) => void;\n}\n\nconst SSEContext = createContext<SSEContextType | undefined>(undefined);\n\nexport const SocketProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [connected, setConnected] = useState(false); // SSE connection\n  const [socketConnected, setSocketConnected] = useState(false); // Socket.IO connection\n  const [eventSource, setEventSource] = useState<EventSource | null>(null);\n  const [socket, setSocket] = useState<Socket | null>(null);\n  const { user } = useAuth();\n  \n  // Use refs to store callbacks to avoid recreating connections\n  const workOrderCallbacksRef = useRef<((update: WorkOrderUpdate) => void)[]>([]);\n  const generalCallbacksRef = useRef<((data: any) => void)[]>([]);\n\n  // SSE Connection Setup\n  useEffect(() => {\n    const token = localStorage.getItem('auth_token');\n    if (!token) {\n      console.log('‚ùå No auth token available for SSE');\n      return;\n    }\n\n    const isDev = process.env.NODE_ENV === 'development';\n    \n    // Always use production URL for SSE since we're running local dev against production\n    const baseUrl = isDev \n      ? 'https://smtdatabase01-production.up.railway.app'\n      : window.location.origin;\n\n    // Include token in URL since EventSource doesn't support custom headers\n    const eventSourceUrl = `${baseUrl}/api/events?token=${encodeURIComponent(token)}`;\n    console.log('Connecting to SSE server:', eventSourceUrl);\n\n    // Create EventSource connection\n    const newEventSource = new EventSource(eventSourceUrl);\n    \n    newEventSource.onopen = () => {\n      console.log('‚úÖ Connected to SSE server');\n      setConnected(true);\n    };\n\n    newEventSource.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        console.log('üì° Received SSE update:', data);\n\n        // Route the update to appropriate callbacks\n        if (data.type === 'work_order_update') {\n          workOrderCallbacksRef.current.forEach(callback => {\n            try {\n              callback(data);\n            } catch (error) {\n              console.error('Error in work order callback:', error);\n            }\n          });\n        } else {\n          // General update - send to all general callbacks\n          generalCallbacksRef.current.forEach(callback => {\n            try {\n              callback(data);\n            } catch (error) {\n              console.error('Error in general callback:', error);\n            }\n          });\n        }\n      } catch (error) {\n        console.error('Error parsing SSE message:', error);\n      }\n    };\n\n    newEventSource.onerror = (error) => {\n      console.error('‚ùå SSE connection error:', error);\n      setConnected(false);\n    };\n\n    setEventSource(newEventSource);\n\n    // Cleanup on unmount\n    return () => {\n      console.log('üîå Closing SSE connection');\n      newEventSource.close();\n      setConnected(false);\n    };\n  }, [user]); // Depend on user to reconnect when auth changes\n\n  // Socket.IO Connection Setup\n  useEffect(() => {\n    const token = localStorage.getItem('auth_token');\n    if (!token) {\n      console.log('‚ùå No auth token available for Socket.IO');\n      return;\n    }\n\n    const isDev = process.env.NODE_ENV === 'development';\n    const baseUrl = isDev \n      ? 'https://smtdatabase01-production.up.railway.app'\n      : window.location.origin;\n\n    console.log('üîå Connecting to Socket.IO server:', baseUrl);\n\n    // Create Socket.IO connection with auth\n    const newSocket = io(baseUrl, {\n      auth: {\n        token: token\n      }\n    });\n\n    newSocket.on('connect', () => {\n      console.log('‚úÖ Connected to Socket.IO server');\n      setSocketConnected(true);\n    });\n\n    newSocket.on('disconnect', () => {\n      console.log('‚ùå Disconnected from Socket.IO server');\n      setSocketConnected(false);\n    });\n\n    newSocket.on('connected', (data) => {\n      console.log('üîó Socket.IO handshake:', data);\n    });\n\n    newSocket.on('work_order_update', (data) => {\n      console.log('üöÄ Received Socket.IO work order update:', data);\n      \n      // Route to work order callbacks (same as SSE)\n      workOrderCallbacksRef.current.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error('Error in Socket.IO work order callback:', error);\n        }\n      });\n    });\n\n    newSocket.on('error', (error) => {\n      console.error('‚ùå Socket.IO error:', error);\n    });\n\n    setSocket(newSocket);\n\n    // Cleanup on unmount\n    return () => {\n      console.log('üîå Closing Socket.IO connection');\n      newSocket.disconnect();\n      setSocketConnected(false);\n    };\n  }, [user]);\n\n  const onWorkOrderUpdate = (callback: (update: WorkOrderUpdate) => void) => {\n    workOrderCallbacksRef.current.push(callback);\n    \n    // Return cleanup function\n    return () => {\n      workOrderCallbacksRef.current = workOrderCallbacksRef.current.filter(cb => cb !== callback);\n    };\n  };\n\n  const onGeneralUpdate = (callback: (data: any) => void) => {\n    generalCallbacksRef.current.push(callback);\n    \n    // Return cleanup function\n    return () => {\n      generalCallbacksRef.current = generalCallbacksRef.current.filter(cb => cb !== callback);\n    };\n  };\n\n  const joinRooms = (rooms: string[]) => {\n    if (socket && socketConnected) {\n      rooms.forEach(room => {\n        console.log(`üè† Joining Socket.IO room: ${room}`);\n        socket.emit('join_room', { room });\n      });\n    } else {\n      console.log('‚ö†Ô∏è Socket.IO not connected, cannot join rooms');\n    }\n  };\n\n  return (\n    <SSEContext.Provider value={{\n      connected,\n      socketConnected,\n      onWorkOrderUpdate,\n      onGeneralUpdate,\n      joinRooms\n    }}>\n      {children}\n    </SSEContext.Provider>\n  );\n};\n\nexport const useSocket = () => {\n  const context = useContext(SSEContext);\n  if (context === undefined) {\n    throw new Error('useSocket must be used within a SocketProvider');\n  }\n  return context;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}