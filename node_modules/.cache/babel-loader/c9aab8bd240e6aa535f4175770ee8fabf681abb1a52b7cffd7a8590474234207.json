{"ast":null,"code":"var _jsxFileName = \"/Users/mattspacegrey/Documents/GitHub/SMT_DATABASE_01/src/contexts/SocketContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect, useRef } from 'react';\nimport { useAuth } from './AuthContext.tsx';\nimport { io } from 'socket.io-client';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SSEContext = /*#__PURE__*/createContext(undefined);\nexport const SocketProvider = ({\n  children\n}) => {\n  _s();\n  const [connected, setConnected] = useState(false); // SSE connection\n  const [socketConnected, setSocketConnected] = useState(false); // Socket.IO connection\n  const [eventSource, setEventSource] = useState(null);\n  const [socket, setSocket] = useState(null);\n  const [roomUsers, setRoomUsers] = useState([]);\n  const [userCount, setUserCount] = useState(0);\n  const {\n    user\n  } = useAuth();\n\n  // Use refs to store callbacks to avoid recreating connections\n  const workOrderCallbacksRef = useRef([]);\n  const generalCallbacksRef = useRef([]);\n  const userJoinedCallbacksRef = useRef([]);\n  const userLeftCallbacksRef = useRef([]);\n  const timelineInteractionCallbacksRef = useRef([]);\n\n  // SSE Connection Setup\n  useEffect(() => {\n    const token = localStorage.getItem('auth_token');\n    if (!token) {\n      console.log('❌ No auth token available for SSE');\n      return;\n    }\n    const isDev = process.env.NODE_ENV === 'development';\n\n    // Always use production URL for SSE since we're running local dev against production\n    const baseUrl = isDev ? 'https://smtdatabase01-production.up.railway.app' : window.location.origin;\n\n    // Include token in URL since EventSource doesn't support custom headers\n    const eventSourceUrl = `${baseUrl}/api/events?token=${encodeURIComponent(token)}`;\n    console.log('Connecting to SSE server:', eventSourceUrl);\n\n    // Create EventSource connection\n    const newEventSource = new EventSource(eventSourceUrl);\n    newEventSource.onopen = () => {\n      console.log('✅ Connected to SSE server');\n      setConnected(true);\n    };\n    newEventSource.onmessage = event => {\n      try {\n        const data = JSON.parse(event.data);\n        console.log('📡 Received SSE update:', data);\n\n        // Route the update to appropriate callbacks\n        if (data.type === 'work_order_update') {\n          workOrderCallbacksRef.current.forEach(callback => {\n            try {\n              callback(data);\n            } catch (error) {\n              console.error('Error in work order callback:', error);\n            }\n          });\n        } else {\n          // General update - send to all general callbacks\n          generalCallbacksRef.current.forEach(callback => {\n            try {\n              callback(data);\n            } catch (error) {\n              console.error('Error in general callback:', error);\n            }\n          });\n        }\n      } catch (error) {\n        console.error('Error parsing SSE message:', error);\n      }\n    };\n    newEventSource.onerror = error => {\n      console.error('❌ SSE connection error:', error);\n      setConnected(false);\n    };\n    setEventSource(newEventSource);\n\n    // Cleanup on unmount\n    return () => {\n      console.log('🔌 Closing SSE connection');\n      newEventSource.close();\n      setConnected(false);\n    };\n  }, [user]); // Depend on user to reconnect when auth changes\n\n  // Socket.IO Connection Setup with Phase 3 Features\n  useEffect(() => {\n    const token = localStorage.getItem('auth_token');\n    if (!token) {\n      console.log('❌ No auth token available for Socket.IO');\n      return;\n    }\n    const isDev = process.env.NODE_ENV === 'development';\n    const baseUrl = isDev ? 'https://smtdatabase01-production.up.railway.app' : window.location.origin;\n    console.log('🔌 Connecting to Socket.IO server:', baseUrl);\n\n    // Create Socket.IO connection with auth\n    const newSocket = io(baseUrl, {\n      auth: {\n        token: token\n      }\n    });\n    newSocket.on('connect', () => {\n      console.log('✅ Connected to Socket.IO server');\n      setSocketConnected(true);\n    });\n    newSocket.on('disconnect', () => {\n      console.log('❌ Disconnected from Socket.IO server');\n      setSocketConnected(false);\n      setRoomUsers([]);\n      setUserCount(0);\n    });\n    newSocket.on('connected', data => {\n      console.log('🔗 Socket.IO handshake:', data);\n    });\n    newSocket.on('work_order_update', data => {\n      console.log('🚀 Received Socket.IO work order update:', data);\n\n      // Route to work order callbacks (same as SSE)\n      workOrderCallbacksRef.current.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error('Error in Socket.IO work order callback:', error);\n        }\n      });\n    });\n\n    // Phase 3: User presence events\n    newSocket.on('room_joined', data => {\n      console.log('🏠 Room joined:', data);\n      if (data.users_in_room) {\n        setRoomUsers(data.users_in_room);\n        setUserCount(data.user_count);\n      }\n    });\n    newSocket.on('user_joined_room', data => {\n      console.log('👋 User joined room:', data);\n      setUserCount(data.user_count);\n      userJoinedCallbacksRef.current.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error('Error in user joined callback:', error);\n        }\n      });\n    });\n    newSocket.on('user_left_room', data => {\n      console.log('👋 User left room:', data);\n      setUserCount(data.user_count);\n      userLeftCallbacksRef.current.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error('Error in user left callback:', error);\n        }\n      });\n    });\n    newSocket.on('room_users_update', data => {\n      console.log('👥 Room users update:', data);\n      setRoomUsers(data.users);\n      setUserCount(data.user_count);\n    });\n\n    // Timeline interaction events\n    newSocket.on('timeline_work_order_selected', data => {\n      console.log('🎯 Timeline work order selected:', data);\n      timelineInteractionCallbacksRef.current.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error('Error in timeline interaction callback:', error);\n        }\n      });\n    });\n    newSocket.on('timeline_status_change_start', data => {\n      console.log('🔄 Timeline status change start:', data);\n      timelineInteractionCallbacksRef.current.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error('Error in timeline interaction callback:', error);\n        }\n      });\n    });\n    newSocket.on('error', error => {\n      console.error('❌ Socket.IO error:', error);\n    });\n    setSocket(newSocket);\n\n    // Cleanup on unmount\n    return () => {\n      console.log('🔌 Closing Socket.IO connection');\n      newSocket.disconnect();\n      setSocketConnected(false);\n      setRoomUsers([]);\n      setUserCount(0);\n    };\n  }, [user]);\n  const onWorkOrderUpdate = callback => {\n    workOrderCallbacksRef.current.push(callback);\n\n    // Return cleanup function\n    return () => {\n      workOrderCallbacksRef.current = workOrderCallbacksRef.current.filter(cb => cb !== callback);\n    };\n  };\n  const onGeneralUpdate = callback => {\n    generalCallbacksRef.current.push(callback);\n\n    // Return cleanup function\n    return () => {\n      generalCallbacksRef.current = generalCallbacksRef.current.filter(cb => cb !== callback);\n    };\n  };\n  const onUserJoinedRoom = callback => {\n    userJoinedCallbacksRef.current.push(callback);\n    return () => {\n      userJoinedCallbacksRef.current = userJoinedCallbacksRef.current.filter(cb => cb !== callback);\n    };\n  };\n  const onUserLeftRoom = callback => {\n    userLeftCallbacksRef.current.push(callback);\n    return () => {\n      userLeftCallbacksRef.current = userLeftCallbacksRef.current.filter(cb => cb !== callback);\n    };\n  };\n  const onTimelineInteraction = callback => {\n    timelineInteractionCallbacksRef.current.push(callback);\n    return () => {\n      timelineInteractionCallbacksRef.current = timelineInteractionCallbacksRef.current.filter(cb => cb !== callback);\n    };\n  };\n  const joinRooms = rooms => {\n    if (socket && socketConnected) {\n      rooms.forEach(room => {\n        console.log(`🏠 Joining Socket.IO room: ${room}`);\n        socket.emit('join_room', {\n          room\n        });\n      });\n    } else {\n      console.log('⚠️ Socket.IO not connected, cannot join rooms');\n    }\n  };\n  const sendTimelineInteraction = (type, workOrderId, workOrderNumber) => {\n    if (socket && socketConnected) {\n      socket.emit('timeline_interaction', {\n        type,\n        work_order_id: workOrderId,\n        work_order_number: workOrderNumber\n      });\n    }\n  };\n  const getRoomUsers = room => {\n    if (socket && socketConnected) {\n      socket.emit('get_room_users', {\n        room\n      });\n    }\n  };\n  const emit = (event, data) => {\n    if (socket && socketConnected) {\n      socket.emit(event, data);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(SSEContext.Provider, {\n    value: {\n      connected,\n      socketConnected,\n      onWorkOrderUpdate,\n      onGeneralUpdate,\n      joinRooms,\n      roomUsers,\n      userCount,\n      onUserJoinedRoom,\n      onUserLeftRoom,\n      onTimelineInteraction,\n      sendTimelineInteraction,\n      getRoomUsers\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 363,\n    columnNumber: 5\n  }, this);\n};\n_s(SocketProvider, \"Vk48zd2YXlsv3eNt+QWpe1+2L8o=\", false, function () {\n  return [useAuth];\n});\n_c = SocketProvider;\nexport const useSocket = () => {\n  _s2();\n  const context = useContext(SSEContext);\n  if (context === undefined) {\n    throw new Error('useSocket must be used within a SocketProvider');\n  }\n  return context;\n};\n_s2(useSocket, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"SocketProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useRef","useAuth","io","jsxDEV","_jsxDEV","SSEContext","undefined","SocketProvider","children","_s","connected","setConnected","socketConnected","setSocketConnected","eventSource","setEventSource","socket","setSocket","roomUsers","setRoomUsers","userCount","setUserCount","user","workOrderCallbacksRef","generalCallbacksRef","userJoinedCallbacksRef","userLeftCallbacksRef","timelineInteractionCallbacksRef","token","localStorage","getItem","console","log","isDev","process","env","NODE_ENV","baseUrl","window","location","origin","eventSourceUrl","encodeURIComponent","newEventSource","EventSource","onopen","onmessage","event","data","JSON","parse","type","current","forEach","callback","error","onerror","close","newSocket","auth","on","users_in_room","user_count","users","disconnect","onWorkOrderUpdate","push","filter","cb","onGeneralUpdate","onUserJoinedRoom","onUserLeftRoom","onTimelineInteraction","joinRooms","rooms","room","emit","sendTimelineInteraction","workOrderId","workOrderNumber","work_order_id","work_order_number","getRoomUsers","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useSocket","_s2","context","Error","$RefreshReg$"],"sources":["/Users/mattspacegrey/Documents/GitHub/SMT_DATABASE_01/src/contexts/SocketContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, useRef, ReactNode } from 'react';\nimport { useAuth } from './AuthContext.tsx';\nimport { io, Socket } from 'socket.io-client';\n\ninterface WorkOrderUpdate {\n  type: 'work_order_update';\n  work_order: {\n    id: string;\n    work_order_number: string;\n    qr_code?: string;\n    customer_name: string;\n    assembly_number: string;\n    line_name?: string;\n    line_number?: number;\n    status: string;\n    quantity?: number;\n    trolley_number?: number;\n  };\n  status_change: {\n    old_status: string;\n    new_status: string;\n    updated_by: string;\n    timestamp: string;\n  };\n  timestamp: string;\n}\n\ninterface RoomUser {\n  user_id: string;\n  username: string;\n  role: string;\n}\n\ninterface UserPresence {\n  user: RoomUser;\n  room: string;\n  user_count: number;\n  timestamp: string;\n}\n\ninterface TimelineInteraction {\n  user: RoomUser;\n  work_order_id: string;\n  work_order_number: string;\n  timestamp: string;\n}\n\ninterface SSEContextType {\n  connected: boolean;\n  socketConnected: boolean;\n  onWorkOrderUpdate: (callback: (update: WorkOrderUpdate) => void) => () => void;\n  onGeneralUpdate: (callback: (data: any) => void) => () => void;\n  joinRooms: (rooms: string[]) => void;\n  // Phase 3 features\n  roomUsers: RoomUser[];\n  userCount: number;\n  onUserJoinedRoom: (callback: (data: UserPresence) => void) => () => void;\n  onUserLeftRoom: (callback: (data: UserPresence) => void) => () => void;\n  onTimelineInteraction: (callback: (data: TimelineInteraction) => void) => () => void;\n  sendTimelineInteraction: (type: string, workOrderId: string, workOrderNumber: string) => void;\n  getRoomUsers: (room: string) => void;\n  emit: (event: string, data: any) => void;\n}\n\nconst SSEContext = createContext<SSEContextType | undefined>(undefined);\n\nexport const SocketProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const [connected, setConnected] = useState(false); // SSE connection\n  const [socketConnected, setSocketConnected] = useState(false); // Socket.IO connection\n  const [eventSource, setEventSource] = useState<EventSource | null>(null);\n  const [socket, setSocket] = useState<Socket | null>(null);\n  const [roomUsers, setRoomUsers] = useState<RoomUser[]>([]);\n  const [userCount, setUserCount] = useState(0);\n  const { user } = useAuth();\n  \n  // Use refs to store callbacks to avoid recreating connections\n  const workOrderCallbacksRef = useRef<((update: WorkOrderUpdate) => void)[]>([]);\n  const generalCallbacksRef = useRef<((data: any) => void)[]>([]);\n  const userJoinedCallbacksRef = useRef<((data: UserPresence) => void)[]>([]);\n  const userLeftCallbacksRef = useRef<((data: UserPresence) => void)[]>([]);\n  const timelineInteractionCallbacksRef = useRef<((data: TimelineInteraction) => void)[]>([]);\n\n  // SSE Connection Setup\n  useEffect(() => {\n    const token = localStorage.getItem('auth_token');\n    if (!token) {\n      console.log('❌ No auth token available for SSE');\n      return;\n    }\n\n    const isDev = process.env.NODE_ENV === 'development';\n    \n    // Always use production URL for SSE since we're running local dev against production\n    const baseUrl = isDev \n      ? 'https://smtdatabase01-production.up.railway.app'\n      : window.location.origin;\n\n    // Include token in URL since EventSource doesn't support custom headers\n    const eventSourceUrl = `${baseUrl}/api/events?token=${encodeURIComponent(token)}`;\n    console.log('Connecting to SSE server:', eventSourceUrl);\n\n    // Create EventSource connection\n    const newEventSource = new EventSource(eventSourceUrl);\n    \n    newEventSource.onopen = () => {\n      console.log('✅ Connected to SSE server');\n      setConnected(true);\n    };\n\n    newEventSource.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        console.log('📡 Received SSE update:', data);\n\n        // Route the update to appropriate callbacks\n        if (data.type === 'work_order_update') {\n          workOrderCallbacksRef.current.forEach(callback => {\n            try {\n              callback(data);\n            } catch (error) {\n              console.error('Error in work order callback:', error);\n            }\n          });\n        } else {\n          // General update - send to all general callbacks\n          generalCallbacksRef.current.forEach(callback => {\n            try {\n              callback(data);\n            } catch (error) {\n              console.error('Error in general callback:', error);\n            }\n          });\n        }\n      } catch (error) {\n        console.error('Error parsing SSE message:', error);\n      }\n    };\n\n    newEventSource.onerror = (error) => {\n      console.error('❌ SSE connection error:', error);\n      setConnected(false);\n    };\n\n    setEventSource(newEventSource);\n\n    // Cleanup on unmount\n    return () => {\n      console.log('🔌 Closing SSE connection');\n      newEventSource.close();\n      setConnected(false);\n    };\n  }, [user]); // Depend on user to reconnect when auth changes\n\n  // Socket.IO Connection Setup with Phase 3 Features\n  useEffect(() => {\n    const token = localStorage.getItem('auth_token');\n    if (!token) {\n      console.log('❌ No auth token available for Socket.IO');\n      return;\n    }\n\n    const isDev = process.env.NODE_ENV === 'development';\n    const baseUrl = isDev \n      ? 'https://smtdatabase01-production.up.railway.app'\n      : window.location.origin;\n\n    console.log('🔌 Connecting to Socket.IO server:', baseUrl);\n\n    // Create Socket.IO connection with auth\n    const newSocket = io(baseUrl, {\n      auth: {\n        token: token\n      }\n    });\n\n    newSocket.on('connect', () => {\n      console.log('✅ Connected to Socket.IO server');\n      setSocketConnected(true);\n    });\n\n    newSocket.on('disconnect', () => {\n      console.log('❌ Disconnected from Socket.IO server');\n      setSocketConnected(false);\n      setRoomUsers([]);\n      setUserCount(0);\n    });\n\n    newSocket.on('connected', (data) => {\n      console.log('🔗 Socket.IO handshake:', data);\n    });\n\n    newSocket.on('work_order_update', (data) => {\n      console.log('🚀 Received Socket.IO work order update:', data);\n      \n      // Route to work order callbacks (same as SSE)\n      workOrderCallbacksRef.current.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error('Error in Socket.IO work order callback:', error);\n        }\n      });\n    });\n\n    // Phase 3: User presence events\n    newSocket.on('room_joined', (data) => {\n      console.log('🏠 Room joined:', data);\n      if (data.users_in_room) {\n        setRoomUsers(data.users_in_room);\n        setUserCount(data.user_count);\n      }\n    });\n\n    newSocket.on('user_joined_room', (data) => {\n      console.log('👋 User joined room:', data);\n      setUserCount(data.user_count);\n      \n      userJoinedCallbacksRef.current.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error('Error in user joined callback:', error);\n        }\n      });\n    });\n\n    newSocket.on('user_left_room', (data) => {\n      console.log('👋 User left room:', data);\n      setUserCount(data.user_count);\n      \n      userLeftCallbacksRef.current.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error('Error in user left callback:', error);\n        }\n      });\n    });\n\n    newSocket.on('room_users_update', (data) => {\n      console.log('👥 Room users update:', data);\n      setRoomUsers(data.users);\n      setUserCount(data.user_count);\n    });\n\n    // Timeline interaction events\n    newSocket.on('timeline_work_order_selected', (data) => {\n      console.log('🎯 Timeline work order selected:', data);\n      \n      timelineInteractionCallbacksRef.current.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error('Error in timeline interaction callback:', error);\n        }\n      });\n    });\n\n    newSocket.on('timeline_status_change_start', (data) => {\n      console.log('🔄 Timeline status change start:', data);\n      \n      timelineInteractionCallbacksRef.current.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error('Error in timeline interaction callback:', error);\n        }\n      });\n    });\n\n    newSocket.on('error', (error) => {\n      console.error('❌ Socket.IO error:', error);\n    });\n\n    setSocket(newSocket);\n\n    // Cleanup on unmount\n    return () => {\n      console.log('🔌 Closing Socket.IO connection');\n      newSocket.disconnect();\n      setSocketConnected(false);\n      setRoomUsers([]);\n      setUserCount(0);\n    };\n  }, [user]);\n\n  const onWorkOrderUpdate = (callback: (update: WorkOrderUpdate) => void) => {\n    workOrderCallbacksRef.current.push(callback);\n    \n    // Return cleanup function\n    return () => {\n      workOrderCallbacksRef.current = workOrderCallbacksRef.current.filter(cb => cb !== callback);\n    };\n  };\n\n  const onGeneralUpdate = (callback: (data: any) => void) => {\n    generalCallbacksRef.current.push(callback);\n    \n    // Return cleanup function\n    return () => {\n      generalCallbacksRef.current = generalCallbacksRef.current.filter(cb => cb !== callback);\n    };\n  };\n\n  const onUserJoinedRoom = (callback: (data: UserPresence) => void) => {\n    userJoinedCallbacksRef.current.push(callback);\n    \n    return () => {\n      userJoinedCallbacksRef.current = userJoinedCallbacksRef.current.filter(cb => cb !== callback);\n    };\n  };\n\n  const onUserLeftRoom = (callback: (data: UserPresence) => void) => {\n    userLeftCallbacksRef.current.push(callback);\n    \n    return () => {\n      userLeftCallbacksRef.current = userLeftCallbacksRef.current.filter(cb => cb !== callback);\n    };\n  };\n\n  const onTimelineInteraction = (callback: (data: TimelineInteraction) => void) => {\n    timelineInteractionCallbacksRef.current.push(callback);\n    \n    return () => {\n      timelineInteractionCallbacksRef.current = timelineInteractionCallbacksRef.current.filter(cb => cb !== callback);\n    };\n  };\n\n  const joinRooms = (rooms: string[]) => {\n    if (socket && socketConnected) {\n      rooms.forEach(room => {\n        console.log(`🏠 Joining Socket.IO room: ${room}`);\n        socket.emit('join_room', { room });\n      });\n    } else {\n      console.log('⚠️ Socket.IO not connected, cannot join rooms');\n    }\n  };\n\n  const sendTimelineInteraction = (type: string, workOrderId: string, workOrderNumber: string) => {\n    if (socket && socketConnected) {\n      socket.emit('timeline_interaction', {\n        type,\n        work_order_id: workOrderId,\n        work_order_number: workOrderNumber\n      });\n    }\n  };\n\n  const getRoomUsers = (room: string) => {\n    if (socket && socketConnected) {\n      socket.emit('get_room_users', { room });\n    }\n  };\n\n  const emit = (event: string, data: any) => {\n    if (socket && socketConnected) {\n      socket.emit(event, data);\n    }\n  };\n\n  return (\n    <SSEContext.Provider value={{\n      connected,\n      socketConnected,\n      onWorkOrderUpdate,\n      onGeneralUpdate,\n      joinRooms,\n      roomUsers,\n      userCount,\n      onUserJoinedRoom,\n      onUserLeftRoom,\n      onTimelineInteraction,\n      sendTimelineInteraction,\n      getRoomUsers\n    }}>\n      {children}\n    </SSEContext.Provider>\n  );\n};\n\nexport const useSocket = () => {\n  const context = useContext(SSEContext);\n  if (context === undefined) {\n    throw new Error('useSocket must be used within a SocketProvider');\n  }\n  return context;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}